generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("PRISMA_URL")
}

model Session {
  id                        Int        @id @default(autoincrement())
  publicId                  String     @unique @default(uuid())
  refreshToken              String     @unique
  userId                    Int
  user                      User       @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  businesses                Business[] @relation("BusinessSessionTable")
  deviceId                  String?    @unique
  isOnline                  Boolean    @default(true)
  lastAccessTs              DateTime   @db.Timestamp()
  openAppNotificationCount  Int?       @default(0)
  openAppNotifcationSending Boolean    @default(false)
}

model ApiKey {
  id    Int    @id @default(autoincrement())
  name  String
  value String
}

model User {
  id                           Int        @id @default(autoincrement())
  orderingUserId               Int        @unique
  orderingAccessToken          String     @unique
  orderingAccessTokenExpiredAt DateTime   @db.Timestamp()
  firstName                    String
  lastName                     String
  email                        String     @unique
  hash                         String
  level                        Int?
  publicId                     String     @unique @default(uuid())
  sessions                     Session[]
  businesses                   Business[] @relation("MyUserBusinessTable")

  @@map("user")
}

model Business {
  id                   Int                    @id @default(autoincrement())
  orderingBusinessId   String                 @unique
  publicId             String                 @unique @default(uuid())
  name                 String
  owners               User[]                 @relation("MyUserBusinessTable")
  sessions             Session[]              @relation("BusinessSessionTable")
  logo                 String?
  email                String?
  phone                String?
  address              String?
  description          String?
  orders               Order[]                @relation("BusinessOrder")
  businessExtraSetting BusinessExtraSetting[] @relation("BusinessExtraSettings")

  @@map("business")
}

model BusinessExtraSetting {
  id                 Int      @unique @default(autoincrement())
  orderingBusinessId String   @unique
  business           Business @relation("BusinessExtraSettings", fields: [orderingBusinessId], references: [orderingBusinessId])
  name               String?
  value              String?  @unique
}

model Order {
  id                 Int       @id @default(autoincrement())
  orderId            String    @unique
  provider           String
  orderingBusinessId String
  business           Business  @relation("BusinessOrder", fields: [orderingBusinessId], references: [orderingBusinessId])
  status             String
  deliveryType       Int
  preparedIn         String?
  createdAt          String
  comment            String?
  preorder           PreOrder? @relation("preorder")
  products           Product[] @relation("order-product")
  offers             Offer[]   @relation("order-offer")
}

//Preorder
model PreOrder {
  id           Int    @id @default(autoincrement())
  status       String
  preorderTime String
  orderId      String @unique
  order        Order? @relation("preorder", fields: [orderId], references: [orderId], onDelete: Cascade, onUpdate: Cascade)
}

//Order product
model Product {
  id       String   @id @unique
  name     String
  quantity Int
  price    String // Replace with the appropriate type for your use case
  comment  String?
  orderId  String   @unique
  order    Order    @relation("order-product", fields: [orderId], references: [orderId], onDelete: Cascade, onUpdate: Cascade)
  option   Option[] @relation("product-option")
}

model Option {
  id        String      @id
  name      String
  image     String?
  price     String? // Replace with the appropriate type for your use case
  productId String
  product   Product     @relation("product-option", fields: [productId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  subOption SubOption[] @relation("option-suboption")
}

model SubOption {
  id       String  @id @unique
  name     String
  image    String?
  price    String // Replace with the appropriate type for your use case
  position Int?
  quantity Int
  optionId String
  option   Option  @relation("option-suboption", fields: [optionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

//Order summary price

//Order offer
model Offer {
  id        String        @id @unique @default(uuid())
  name      String
  label     String
  type      Int
  rate_type String
  rate      Float
  summary   OfferSummary? @relation("offer-summary")
  orderId   String        @unique
  order     Order         @relation("order-offer", fields: [orderId], references: [orderId])
}

model OfferSummary {
  id       String @id @unique @default(uuid())
  offerId  String @unique
  offer    Offer? @relation("offer-summary", fields: [offerId], references: [id])
  discount String
}

model Notification {
  id          Int      @id @default(autoincrement())
  type        String
  deviceId    String
  businessId  String
  scheduledAt DateTime @db.Timestamp()
  userId      Int

  @@map("notification")
}

model ActiveStatusQueue {
  id               Int      @id @default(autoincrement())
  userPublicId     String   @unique
  businessPublicId String   @unique
  time             DateTime @db.Timestamp()
  provider         String
  processing       Boolean  @default(false)

  @@map("active_status_queue")
}
